push_swap


?? 터미널에서 3개 5개 100개 500개 이렇게 받아서 확인을 할 텐데, 터미널에서 정수를 어떻게 받는지? 그 원리를 알아야 할듯. int main(int argc, char *argv[]){} 이런 형태일 텐데... 예들을어 1 2 3 이렇게 오면 argc = 4이고, argv[1] = 1, argv[2]= 2, argv[3] = 3 이렇게 받잖아. 아니면 argv[1]에 "1 2 3" 이게 한번에 들어오는 거임?
1. 빈 문자열에 대한 예외처리
그러면 터미널에서 ./push_swap 을 실행한다고 할 때, 빈문자열일 경우는 ./push_swap, ./push_swap "", ./push_swap '', ./push_swap "            " 등 이런거일거 아니냐. 이걸 다 argc < 2 이하에 들어가는 상황인지 궁금.
2. 유효하지 않는 입력
비숫자, int형을 벗어나는 범위, 실수형 등이 이에 해당하겠지? 이걸 확인하려면 argv에 들어온 값들을 하나하나 돌면서 확인해야하는건가? utils.c에 있는 ft_atoi() 함수에 argument에 들어갈 수 있는 자료형인지 확인하면 되는 건가?
3. ./push_swap 1 2 3 과 ./push_swap "1 2 3" 과 ./push_swap "1" "2" "3" 과 ./push_swap '1' '2' '3' 과 ./push_swap 1 '2' "3" 등이 다 같은 의미인지 궁금하다. 어떻게 터미널이 이걸 구분하고 혹은 같은취급하는지 궁금.


/push_swap 1 2 3 4 이 입력으로 온다고 가정. argc = 5, argv[1] = 1, argv[2] = 2, argv[3] = 3, argv[4] = 4 일 거임. 그리고 각 argv의 값들은 문자형태지? int main(int argc, char *argv[]) 의 형태니까.
1. 빈 문자열인지 공백 문자열인지 체크, 숫자가 아닌 문자 포함 여부 체크(- 의 위치, -가 나오고 숫자문자의 유무도 고려)
2. ft_atoi를 이용해서 argv[] 의 값을 integer로 바꿔주는 거임. 들어온 인자는 (argc - 1)하면 됨.
3. 바꿔준 값들을 배열을 만들어서 저장해야할거 같음. int arr[4] 를 하든 malloc(sizeof(int) * 4) 하면될거 같은데, 정적할당으로 선언하는거랑 동적할당으로 하는 거랑 크게 차이가 있나? -> 정적배열선언 못함. 배열의 크기를 변수로 넣어줄 수 없음. 그러니까 동적할당밖에 안됨. 배열에 넣기 전에 여기서 확인하는거지. 중복인지, int범위인지
너가 알려준 pseudo code for validation 여기에는 바로 stack a에 넣는데, 어차피 argv[1]은 stack 의 가장 바깥에 있어야 하잖아. 그러니까 마지막에 들어가는게 좋잖아. 그러니까 배열에 넣어서 꺼꾸로 stack a에 넣는 방법도 괜찮지 않나 하는 생각이 든다. 또한 radix sort를 생각한다면 index로 바꿔줘야 하는데, stack에 넣어서 정렬을 다시하고 인덱스를 붙이는 것보단, 배열을 만들어서 인덱싱을하는게 더 좋지 않나 이런 생각도 든다. 그 다음에 stack a에 배열의 순서 꺼꾸로 넣는거지.
또한 아직 stack에 관해 구현을 시작하지 않았다. 그러니까 배열을 만들어서 하는게 좋다고 생각했다.


?? parsing.c 파일에 함수를 작성하고 있는데, static을 함수 이름 앞에 사용한다든지, libft에서 가져오니까 size_t 변수형이 함수 앞에서 사용되고 있다든지, 함수의 argument에서 const를 사용한다던지 이런 것들이 정확히 어떤 상황에서 사용되는지 알아봐야겠다는 생각이 든다.


?? 입력이 00123 이런식으로 나오면 123으로 인식되게 해야하는건가 아니면 invalid input이라고 해야되나. 또한 -00123은 -123으로 인식되게 해야하는건가 아니면 invalid input이라고 해야되나. +3 이런식으로 입력이 들어오나? 이런게 참 그렇습니다~ 여튼 저런 식으로는 test를 안할 거 같은데... 그러면 ㄹㅇ 숫자 '0' ~ '9'만 인식해서 하면 되는건가. 어차피 입력 예시들보면 004, 002, 이런 정수들은 없긴 했지.
우선 정상적?인 정수입력이라고 상정하여 코드를 작성해보자. -> libft에서 가져오는 ft_atoi와 ft_split함수에 따라서 정하기


?? gemini에게 is_numberic 함수에 대해 물어보는 과정을 가졌음. 궁금한 점은 널 check를 해주었다는 거임. 물론 main함수에서나 앞의 함수들에서 null일 경우나 빈 문자열일 경우는 다 걸러줌. 그런데 걸러줬다고 해서 현재 진행 중인 함수에 또 확인해주는 로직을 넣는 것이 좋은건가 아니면 내가 지금 생각하는대로 안해줘도 되는 건가 의문이 생긴다. 지금 작성하는 방법은 앞에서 걸러줬으니까 안해도 되는 식으로 작성할 것임.


?? exit() 함수를 쓰면 코드를 진행하다가 exit함수를 만나면 여기서 프로그램이 끝나는건가? -> Ne.

?? ./push_swap "1 2 3 4" 와 ./push_swap "1" "2" "3" "4" 를 구분하는 로직을 어떻게 해야하는가. 유효하지 않는 입력을 검증하는 로직을 재활용하고 싶은데 어떻게 하면 좋을지 고민.

??  ./push_swap "1 2 3 4" 와 ./push_swap "1" "2" "3" "4" 말고도 ./push_swap "1" "2" 6 7 5 "3 4 5" 이런식도 입력을 받아야하는건지, 아니면 invalid input으로 생각해야하는 건지...


우선  ./push_swap "1 2 3 4",  ./push_swap "1" "2" "3" "4",  ./push_swap 5 "6" "1 2 3 4" 모두 가능한 입출력을 만들 생각이다.

1. argc == 1이면 바로 종료.
2. spilit을 넣기 전에 count_word를 가지고 malloc할 단어개수를 세줌.
3. split하고 넣은 배열을 만들어줌
4. argv >= 2 이상이면 일단 무족건 split를 넣어야할거 같음. 그래서 char * 배열에 순서대로 다 넣은 상태를 만듬.
5. 그 다음에는 내가 처음에 만든, 즉, ./push_swap "1 2 3 4" 를 만족하는 로직(invalid input)에 넣으면 되지 않을까 한다. 어떤데 나의 로직꾸.

?? argv[i] 를 돌면서 split에 넣는데, 이걸 같은 배열 (char *) 형태에 담아서 split된 각각의 요소?들을 input_word_count로 malloc해서 만든 배열인 split_arr에 인덱스 0번부터 쭉 넣는 로직을 하고 싶은데, 이게 되는 건가?



할일
1. test case 작성 v
2. 1단계 testcode 작성 v
3. 에러난 것들 찾아서 노션에 정리하기 -> 에러가 많은듯;; gemini 대화보고 읽어보며 해당부분 고치기 v
4. makefile, push_swap.h 파일 만들기 v
5. ./push_swap "1 2 3 4" 같은 형식도 받을 수 있도록 만들기. 그러니까 ./push_swap "1" "2" "3" "4" 두 형식 다 가능하게 만들어야 함.
6. test 해보기
7. stack 구현을 어떻게 할건지 생각하기




test case
./push_swap          

./push_swap ""

./push_swap "               "

./push_swap "5 4 3 2 1"

./push_swap "- 3" "-23-1"

./push_swap "-23-1" "5" "4"

./push_swap 23-1 -5 4 3 1

./push_swap 5 4 98- 2 1

./push_swap 1 two 3 4

./push_swap two three four

./push_swap 3 5 1 1 6

./push_swap -4 -3 -2 -1

./push_swap -4 3 2 -1 0

./push_swap 2147483647 5 7

./push_swap 2147483647 2147483648 2 1

./push_swap -2147483648

./push_swap 999999999999 1 2 3

./push_swap "   1 2   4  5" -> 이런것도 1, 2, 3, 4 이렇게 구분해줘야하는건가...?

./push_swap "71 61 25 87 24 22 55 36 83 8 59 97 49 7 21 15 85 17 58 91 16 68 57 69 1 80 40 23 3 95 52 82 75 32 65 2 93 48 88 84 60 56 44 100 14 45 78 33 41 37 72 51 64 43 29 90 74 81 50 11 67 46 35 12 4 30 28 39 20 77 73 98 10 76 54 9 94 92 53 27 13 34 86 63 47 19 18 96 99 66 79 26 6 5 89 31 42 62 70 38"

./push_swap "470 43 172 206 442 132 494 59 67 37 95 216 472 283 133 51 54 104 96 230 323 239 214 146 221 298 124 479 345 13 209 175 152 135 233 445 337 447 31 151 460 413 122 55 263 461 384 380 377 423 40 250 489 309 170 52 272 398 249 405 459 88 130 389 484 375 286 200 426 208 16 140 195 173 285 453 264 189 269 406 424 215 223 415 191 373 201 94 487 213 80 58 69 370 90 486 99 85 44 310 483 326 167 294 109 458 81 32 45 468 440 120 314 257 238 41 83 184 353 464 368 293 452 136 248 333 258 179 372 362 327 393 14 392 60 360 407 419 98 61 232 46 166 274 131 485 498 57 226 192 155 180 154 332 399 97 147 251 267 73 315 301 70 273 252 48 448 457 277 371 431 12 49 157 220 225 414 126 404 260 84 101 427 411 198 376 229 306 115 218 186 26 500 329 129 117 108 164 278 112 134 174 245 145 207 352 331 110 355 276 299 119 143 271 236 128 79 408 210 241 29 417 177 321 467 182 25 87 330 106 435 65 137 412 1 212 300 466 451 2 169 295 354 253 340 7 168 481 171 478 242 420 344 386 18 280 403 74 76 328 107 350 322 439 369 307 463 149 194 228 425 63 387 465 23 335 118 325 163 270 275 401 279 365 342 53 197 185 297 113 304 454 430 9 142 281 418 497 158 397 284 495 480 349 102 268 363 334 89 244 21 247 449 219 71 33 351 429 291 222 243 320 421 160 165 62 38 256 374 36 303 234 409 428 289 491 381 476 240 42 237 148 35 308 446 492 366 78 390 103 361 178 6 22 255 254 462 441 27 324 432 455 34 19 378 469 443 394 482 287 116 64 123 227 68 434 30 56 474 105 114 3 410 141 205 235 422 144 39 188 339 246 139 203 159 402 282 4 346 359 379 288 347 438 475 150 296 11 217 396 17 319 75 338 266 358 196 8 416 231 357 72 471 318 341 77 92 499 24 15 305 456 292 493 86 204 28 395 336 211 66 193 450 473 490 367 156 111 302 100 437 382 10 312 311 5 224 153 50 262 261 190 348 93 161 391 181 202 183 138 313 444 127 316 82 433 388 199 125 477 356 436 290 364 496 265 343 162 20 385 317 176 259 488 91 383 47 187 121 400"


