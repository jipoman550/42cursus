#include <unistd.h>

int main(int argc, char *argv[])
{
	if (argc == 3)
	{
		char *s1 = argv[1];
		char *s2 = argv[2];
		int lookup[256] = {};
		int i = 0;
		while(s1[i])
			lookup[(int)s1[i++]] = 1;
		i = 0;

		while (s2[i])
			lookup[(int)s2[i++]] = 1;
		i = 0;

		while (s1[i])
		{
			if (lookup[(int)s1[i]])
			{
				write(1, &s1[i], 1);
				lookup[(int)s1[i]] = 0;
			}
			i++;
		}
		i = 0;
		while (s2[i])
		{
			if (lookup[(int)s2[i]])
			{
				write(1, &s2[i], 1);
				lookup[(int)s2[i]] = 0;
			}
			i++;
		}
	}
	write(1, "\n", 1);
	return 0;
}

/*
"union" 문제는 두 개의 문자열을 입력받아, 두 문자열에 **모두 나타나는 모든 고유(중복되지 않는) 문자들을 처음 나타난 순서대로 한 번만 출력**하는 프로그램입니다.

예시를 통해 더 자세히 설명해 드릴게요.

* `./union zpadinton "paqefwtdjetyiytjneytjoeyjnejeyj"`
    * 첫 번째 문자열: `zpadinton`
    * 두 번째 문자열: `paqefwtdjetyiytjneytjoeyjnejeyj`
    * 두 문자열에 있는 모든 문자를 순서대로 살펴보면서, 이미 출력된 문자는 건너뛰고 아직 출력되지 않은 문자만 출력합니다.
        * `z` (처음) -> `z` 출력
        * `p` (처음) -> `p` 출력
        * `a` (처음) -> `a` 출력
        * `d` (처음) -> `d` 출력
        * `i` (처음) -> `i` 출력
        * `n` (처음) -> `n` 출력
        * `t` (처음) -> `t` 출력
        * `o` (처음) -> `o` 출력
        * `n` (이미 출력됨) -> 건너뜀
        * 두 번째 문자열로 넘어갑니다.
        * `p` (이미 출력됨) -> 건너뜀
        * `a` (이미 출력됨) -> 건너뜀
        * `q` (처음) -> `q` 출력
        * `e` (처음) -> `e` 출력
        * `f` (처음) -> `f` 출력
        * `w` (처음) -> `w` 출력
        * `t` (이미 출력됨) -> 건너뜀
        * `d` (이미 출력됨) -> 건너뜀
        * `j` (처음) -> `j` 출력
        * `e` (이미 출력됨) -> 건너뜀
        * `t` (이미 출력됨) -> 건너뜀
        * `y` (처음) -> `y` 출력
        * ... 이런 식으로 진행되어 최종적으로 `zpadintoqefwjy`가 출력됩니다.

**요약하자면, 각 문자열의 문자를 앞에서부터 순서대로 확인하면서, 이전에 한 번도 등장하지 않은 문자만 출력하는 문제입니다.**

-------------------------------------------------------------

## `lookup[256]`을 사용하는 이유

`lookup[256]` 배열을 사용하는 이유는 ASCII 코드 범위를 포함하여 **확장 ASCII (Extended ASCII)** 코드까지 처리하기 위함입니다.

1.  **ASCII 코드 (0-127):** 일반적으로 `char` 타입은 1바이트를 사용하며, 이는 256가지 다른 값을 표현할 수 있습니다. 표준 ASCII 문자는 0부터 127까지의 값을 가집니다.
2.  **확장 ASCII (128-255):** 128부터 255까지의 값은 확장 ASCII라고 불리며, 다양한 언어의 특수 문자나 그래픽 문자 등을 표현하는 데 사용됩니다. 예를 들어, 라틴-1 (ISO-8859-1) 인코딩은 0부터 255까지의 모든 값을 사용합니다. C 언어에서 `char` 타입은 부호(signed) 또는 무부호(unsigned)로 정의될 수 있으며, 기본적으로는 컴파일러에 따라 다를 수 있습니다.
    * 만약 `char`가 `signed char`로 처리된다면, 그 값은 보통 -128에서 127까지입니다. 이 경우 128 이상의 ASCII 값은 음수로 변환될 수 있어 배열 인덱스로 사용하기에 문제가 생길 수 있습니다.
    * 하지만 `unsigned char`로 처리된다면 0에서 255까지의 값을 가집니다.

`lookup[256]` 배열을 사용하면, 어떤 문자가 나오든 해당 문자의 ASCII (또는 확장 ASCII) 값을 배열의 인덱스로 사용하여 **해당 문자가 이미 출력되었는지 여부를 효율적으로 기록**할 수 있습니다. 이렇게 하면 문자가 128 이상 255 이하의 값을 가지더라도 문제없이 처리할 수 있습니다.

**안전성 및 호환성:** 128개만 고려하는 것보다 256개를 고려하는 것이 더 다양한 문자 집합과 잠재적인 문자열 인코딩에 대해 **더 강력하고 호환성 있는 코드**를 만들 수 있습니다. 문제에서 어떤 특정 인코딩을 사용한다고 명시하지 않는 한, 256개 전체 범위를 커버하는 것이 안전합니다.
*/