unsigned char swap_bits(unsigned char octet)
{
	return ((octet << 4 | octet >> 4));
}

/*작성하신 swap_bits 함수는 하나의 바이트(octet)를 입력받아 상위 4비트와 하위 4비트의 위치를 바꾸는 코드입니다.

코드 설명
작성하신 코드를 단계별로 자세히 설명해 드릴게요.

octet << 4 (왼쪽 시프트 연산)

octet의 비트들을 왼쪽으로 4칸 이동시킵니다.

예를 들어, octet이 01000001 (이진수)이라면, 왼쪽으로 4칸 이동하면 00010000이 됩니다.

원래 상위 4비트였던 0100은 버려지고, 하위 4비트였던 0001이 상위 4비트 위치로 이동하게 됩니다.

결과적으로 이 연산은 원래 octet의 하위 4비트를 새로운 상위 4비트로 만듭니다.

octet >> 4 (오른쪽 시프트 연산)

octet의 비트들을 오른쪽으로 4칸 이동시킵니다.

octet이 01000001 (이진수)이라면, 오른쪽으로 4칸 이동하면 00000100이 됩니다.

원래 하위 4비트였던 0001은 버려지고, 상위 4비트였던 0100이 하위 4비트 위치로 이동하게 됩니다.

결과적으로 이 연산은 원래 octet의 상위 4비트를 새로운 하위 4비트로 만듭니다.

| (비트 OR 연산)

위의 두 시프트 연산의 결과를 비트 단위로 OR 합니다.

00010000 (하위 4비트가 상위로 이동한 결과)

00000100 (상위 4비트가 하위로 이동한 결과)

이 둘을 OR 연산하면 00010100이 됩니다.

예시 적용
문제에서 제시된 예시를 통해 다시 살펴보겠습니다.

원본 octet: 01000001 (이진수)

octet << 4:
01000001을 왼쪽으로 4칸 이동하면 00010000이 됩니다.
(원래 하위 4비트 0001이 상위 4비트 위치로 왔습니다.)

octet >> 4:
01000001을 오른쪽으로 4칸 이동하면 00000100이 됩니다.
(원래 상위 4비트 0100이 하위 4비트 위치로 왔습니다.)

00010000 | 00000100:
두 결과를 OR 연산하면 00010100이 됩니다.

결과적으로, 0100 | 0001이었던 바이트가 0001 | 0100으로, 상위 4비트와 하위 4비트가 성공적으로 교환된 것을 볼 수 있습니다.*/