unsigned int lcm(unsigned int a, unsigned int b)
{
    unsigned int g = (a > b) ? a : b;

    // Check if any of the integer is null
    if (a == 0 || b == 0)
    	return (0);

    while (1)
    {
    	// if g is perfectly divisible by both a and b
    	// this is the lcm
        if ((g % a == 0) && (g % b == 0))
            return (g);
        g++;
    }
}
// Un-comment the following to test
// #include <stdio.h>
// #include <stdlib.h>
// int main(int ac, char **av)
// {
// 	if (ac == 3)
// 	{
// 		unsigned int m = lcm(atoi(av[1]), atoi(av[2]));
// 		printf("LCM: %u\n", m);
// 	}
// }

/*
제가 **LCM (최소공배수)** 문제에 대해 자세히 설명해 드릴게요.

-----

### 1\. 문제 설명

문제는 `lcm`이라는 C 함수를 작성하는 것으로, 두 개의 부호 없는 정수(`unsigned int`)를 인자로 받아서 그 두 수의 최소공배수를 계산하여 반환해야 합니다.

**LCM이란?**
두 개 이상의 0이 아닌 정수의 **가장 작은 양의 공통 배수**를 의미합니다. 예를 들어, 4와 6의 최소공배수는 12입니다. 12는 4의 배수이면서(4x3=12) 6의 배수(6x2=12)이고, 4와 6의 공통 배수 중 가장 작은 양수이기 때문이죠.

**LCM 계산 방법:**

1.  **각 정수의 배수를 나열하는 방법:**

      * 두 수의 배수를 각각 나열하여 공통된 배수 중 가장 작은 값을 찾습니다.
      * 예: LCM(4, 6)
          * 4의 배수: 4, 8, **12**, 16, 20, **24**...
          * 6의 배수: 6, **12**, 18, **24**, 30...
          * 공통 배수는 12, 24 등이며, 이 중 가장 작은 양수는 12입니다.

2.  **HCF (최대공약수)를 이용하는 방법:**

      * 두 수 `x`와 `y`의 LCM은 다음과 같은 공식으로 계산할 수 있습니다:
        `LCM(x, y) = | x * y | / HCF(x, y)`
        여기서 `| x * y |`는 `x`와 `y`를 곱한 값의 절댓값을 의미합니다. `unsigned int`는 항상 양수이므로, 단순히 `x * y`로 생각하시면 됩니다.
      * 예: LCM(4, 6)
          * HCF(4, 6) (4와 6의 최대공약수)는 2입니다.
          * LCM(4, 6) = (4 \* 6) / HCF(4, 6) = 24 / 2 = 12

**특수한 경우:**

  * 만약 두 인자 중 하나라도 **0**이면, LCM은 **0**을 반환해야 합니다. (0의 배수는 모두 0이므로, 0이 아닌 다른 수와의 공통 배수를 찾을 수 없습니다.)

**함수 프로토타입:**
`unsigned int lcm(unsigned int a, unsigned int b);`
이 형태로 함수를 작성해야 합니다.

-----

### 2\. 작성하신 코드 설명

제공해주신 코드는 LCM을 계산하는 첫 번째 방법, 즉 **두 수의 배수를 하나씩 증가시키면서 가장 먼저 공통으로 나누어떨어지는 값을 찾는 방식**을 사용하고 있습니다.

```c
unsigned int lcm(unsigned int a, unsigned int b)
{
    unsigned int g = (a > b) ? a : b; // (1)

    // Check if any of the integer is null
    if (a == 0 || b == 0) // (2)
        return (0);

    while (1) // (3)
    {
        // if g is perfectly divisible by both a and b
        // this is the lcm
        if ((g % a == 0) && (g % b == 0)) // (4)
            return (g); // (5)
        g++; // (6)
    }
}
```

**코드 작동 방식:**

1.  `unsigned int g = (a > b) ? a : b;`

      * `g` 변수를 선언하고, `a`와 `b` 중 **더 큰 값으로 초기화**합니다.
      * **왜 더 큰 값으로 초기화할까요?** LCM은 항상 두 수 중 더 큰 값보다 크거나 같기 때문입니다. 예를 들어 LCM(4, 6)은 6보다 작을 수 없습니다. 4의 배수이면서 6의 배수여야 하는데, 6보다 작은 6의 배수는 없기 때문이죠. 이렇게 시작하면 불필요하게 작은 수부터 검사하는 것을 피할 수 있습니다.

2.  `if (a == 0 || b == 0)`

      * 문제 요구사항에 따라, **`a` 또는 `b` 중 하나라도 0이면 즉시 0을 반환**합니다. 이 조건은 가장 먼저 검사되어야 합니다.

3.  `while (1)`

      * **무한 루프**입니다. LCM을 찾을 때까지 계속 반복하겠다는 의미입니다.
      * 언젠가는 LCM을 찾아서 `return` 문으로 루프를 빠져나오게 됩니다.

4.  `if ((g % a == 0) && (g % b == 0))`

      * 현재 `g` 값이 `a`로 나누어떨어지고(`g % a == 0`), 동시에 `b`로도 나누어떨어지는지 확인합니다.
      * 즉, `g`가 **`a`와 `b`의 공통 배수인지** 확인하는 것입니다.

5.  `return (g);`

      * 만약 `g`가 `a`와 `b`의 공통 배수라면, 현재의 `g`가 바로 \*\*가장 작은 공통 배수(LCM)\*\*입니다.
      * `g`는 `a`와 `b`의 큰 값부터 1씩 증가시키면서 찾았기 때문에, 이 조건을 만족하는 **첫 번째 `g` 값이 바로 최소공배수**가 됩니다. 따라서 `g`를 반환하고 함수를 종료합니다.

6.  `g++;`

      * `g`가 `a`와 `b`의 공통 배수가 아니라면, `g`를 1 증가시키고 다시 루프의 시작으로 돌아가 다음 `g` 값으로 검사를 계속합니다.

이 코드는 두 수의 공배수를 작은 값부터 순차적으로 탐색하여 가장 먼저 발견되는 값을 LCM으로 반환하기 때문에 정확하게 작동합니다.

이 설명이 이해하는 데 도움이 되었기를 바랍니다\! 궁금한 점이 있다면 언제든지 다시 질문해주세요.
*/