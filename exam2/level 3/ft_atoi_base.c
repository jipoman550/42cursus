/*
** ft_atoi_base.c
**
** 이 함수는 주어진 문자열 'str'을 'str_base' 진법에서 10진법 정수로 변환합니다.
**
** 인수:
** str: 변환할 숫자가 포함된 상수 문자열입니다.
** 유효한 문자는 '0'부터 '9', 'a'부터 'f', 'A'부터 'F'입니다.
** 'str_base'에 따라 문자의 유효성이 결정됩니다.
** 예: str_base가 4일 때 '0', '1', '2', '3'만 유효합니다.
** 대문자('A'-'F')와 소문자('a'-'f')는 동일하게 처리됩니다.
** 문자열의 첫 번째 문자만 마이너스 부호('-')로 해석됩니다.
** str_base: 변환할 숫자의 진법입니다. 2부터 16까지의 정수여야 합니다.
**
** 반환 값:
** 변환된 10진법 정수입니다.
** 'str_base'가 유효하지 않거나(2 미만 또는 16 초과),
** 문자열이 유효한 숫자로 시작하지 않으면 0을 반환합니다.
*/
int	ft_atoi_base(const char *str, int str_base)
{
	int	result;     // 변환된 10진법 숫자를 저장할 변수
	int	sign;       // 숫자의 부호를 저장할 변수 (1 또는 -1)
	int	digit_val;  // 현재 문자의 10진법 값

	result = 0; // 결과 초기화
	sign = 1;   // 부호 초기화 (기본값: 양수)

	// 1. str_base의 유효성 검사
	// str_base가 2 미만 또는 16 초과인 경우 0을 반환하여 잘못된 진법을 처리합니다.
	if (str_base < 2 || str_base > 16)
	{
		return (0);
	}

	// 2. 선행 마이너스 부호 처리
	// 문자열의 첫 번째 문자가 '-'인 경우 부호를 -1로 설정하고,
	// 'str' 포인터를 다음 문자로 이동시킵니다.
	if (*str == '-')
	{
		sign = -1;
		str++; // '-' 문자를 건너뜁니다.
	}

	/*while (isspace(str[i])
        i++;
    // Check if the number is negative
    if (str[i] == '+' && str[i + 1] != '-')
        i++;
    // If the number is negative, set the sign to -1 and skip the '-'
    if (str[i] == '-')
    {
        sign = -1;
        i++;
    }*/

	// 3. 문자열을 순회하며 숫자를 변환
	// 문자열의 끝(널 종료 문자 '\0')에 도달할 때까지 반복합니다.
	while (*str != '\0')
	{
		// 현재 문자의 10진법 값을 결정합니다.
		if (*str >= '0' && *str <= '9')
		{
			// 문자가 '0'에서 '9' 사이인 경우, 해당 숫자 값을 직접 사용합니다.
			digit_val = *str - '0';
		}
		else if (*str >= 'a' && *str <= 'f')
		{
			// 문자가 소문자 'a'에서 'f' 사이인 경우, 10부터 15까지의 값을 할당합니다.
			// (예: 'a'는 10, 'b'는 11 등)
			digit_val = *str - 'a' + 10;
		}
		else if (*str >= 'A' && *str <= 'F')
		{
			// 문자가 대문자 'A'에서 'F' 사이인 경우, 10부터 15까지의 값을 할당합니다.
			// (예: 'A'는 10, 'B'는 11 등)
			digit_val = *str - 'A' + 10;
		}
		else
		{
			// 현재 문자가 '0'-'9', 'a'-'f', 'A'-'F' 중 어느 것도 아닌 경우,
			// 유효하지 않은 문자이므로 변환을 중단합니다.
			break;
		}

		// 현재 문자의 10진법 값이 str_base보다 크거나 같은지 확인합니다.
		// (예: str_base가 4인데 문자가 '4'나 '5'인 경우)
		// 유효하지 않은 숫자이므로 변환을 중단합니다.
		if (digit_val >= str_base)
		{
			break;
		}

		// 현재까지의 결과에 str_base를 곱하고 새 digit_val을 더하여
		// 숫자를 누적합니다.
		result = result * str_base + digit_val;

		str++; // 다음 문자로 이동합니다.
	}

	// 최종 결과에 부호를 적용하여 반환합니다.
	return (result * sign);
}
