구현 방법

1. read 함수로 txt 읽어라
2. 읽은 부분을 출력해봐라
3. get_next_line의 요구사항에 맞게 조건을 추가해라
	read() 함수가 buffer_size 만큼 읽을 텐데, 읽은 buffer중에 \n이 있다면 \n을 포함해서 return 을 해줘야함. 그리고 남은 static buf에 있는 값에서 \n까지 지우고 남은 문자열을 static buf에 다시 저장해줘야하는데, 이때 malloc과 free를 어떻게 활용해야할지 고민임.
	-> 지금 생각하기에는 read로 읽은 buf를 확인하는 동작으로 확인해줘야 할 듯?
	 여기에 \n이나 \0이 없다면 static buf와 read_buf를 strjoin을 해주는 것.
	\n이 있다면 static과 read_buf를 strjoin을 해주고, 조인된 static buf에서 \n까지 잘라서 return하고, return한 부분은 잘라주고, 남아있는 문자열을 static buf에 다시 저장해줘야함.
	\0을 발견했다면(read()의 return 값이 0은 아님 0 < read_value <= buffer_size) strjoin을 해주고, \0까지 다 return 하기.
	혹은 read_value가 0이면 strjoin하지 않고 남아 있는 static buf를 return 하기.


읽음(read 함수) 멈춤 조건
1. buffer size가 찼을 때
	하지만! \n(개행문자)를 만나지 않았으니까
	읽은 만큼을 static variable에 저장을 해줘야됨.
2. \n을 만났을 때 -> 출력
	buffer size랑 상관없이 출력해야됨
	이게 get_next_line 조건임.
3. read의 return 값이 0일 때 (읽을 것이 없을 때?)
	\0 (null 문자)를 만나면 완전 끝내버리기 해야되나?


//main.c
#include <fcntl.h> // open()
#include "get_next_line.h"

int main(void)
{
	int fd = 0;
	char *result = NULL;

	fd = open("example.txt", O_RDONLY);
	while ((result = get_next_line(fd)) != NULL)
	{
		printf("%s", result);
		free(result);
	}
	close(fd);
	return 0;
}

//get_next_line.c
#include "get_next_line.h"

char	*read_and_find_newline_char()
{
	char		*read_buf;

	read_buf = (char *)malloc(BUFFER_SIZE + 1);
	if (!read_buf)
		return (NULL);
}

char	*get_next_line(int fd)
{
	static char	*buf = NULL;
	char		*read_buf;
	int			read_value;
	char		*tmp;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);

	read_buf = (char *)malloc(BUFFER_SIZE + 1);
	if (!read_buf)
		return (NULL);

	read_value = 1;
	while (read_value > 0 && !ft_strchr(read_buf, '\n'))
	{
		read_value = read(fd, read_buf, BUFFER_SIZE);
		if (read_value == 0)
			break ;
		if (read_value == -1)
		{
			free(read_buf);
			return (NULL);
		}
		read_buf[read_value] = '\0';
		tmp = ft_strjoin(buf, read_buf);
		free(buf);
		buf = tmp;
	}
	free(read_buf);

	if (!buf || buf[0] == '\0')
	{
		free(buf);
		buf = NULL;
		return (NULL);
	}

	char	*newline_char = ft_strchr(buf, '\n');
	char	*extract_line;
	char	*next_buf;

	if (newline_char)
	{
		int len = newline_char - buf + 1;
		extract_line = ft_strndup(buf, len);
		next_buf = ft_strndup(buf + len, ft_strlen(buf +len));
		free(buf);
		buf = next_buf;
	}
	else
	{
		extract_line = ft_strndup(buf, ft_strlen(buf));
		free(buf);
		buf = NULL;
	}
	return (extract_line);
}

//get_next_line_utils.c
#include "get_next_line.h"

char	*ft_strndup(const char *s, size_t n)
{
	size_t		i;
	char	*dup;

	if (!s)
		return (NULL);
	dup = (char *)malloc(n + 1);
	if (!dup)
		return (NULL);
	i = 0;
	while (s[i] && i < n)
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (char)c)
			return ((char *)s);
		s++;
	}
	if ((char)c == '\0')
		return ((char *)s);
	return (NULL);
}

size_t	ft_strlen(const char *s)
{
	size_t	cnt;

	if (!s)
		return (0);
	cnt = 0;
	while (*s)
	{
		cnt++;
		s++;
	}
	return (cnt);
}

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t	s1_len;
	size_t	s2_len;
	char	*strjoin;
	char	*p;

	s1_len = ft_strlen(s1);
	s2_len = ft_strlen(s2);
	strjoin = (char *)malloc(s1_len + s2_len + 1);
	if (!strjoin)
		return (NULL);
	p = strjoin;
	while (s1 && *s1)
		*p++ = *s1++;
	while (s2 && *s2)
		*p++ = *s2++;
	*p = '\0';
	return (strjoin);
}

위의 코드를 컴파일해서 실행파일을 가지고 valgrind를 실행했을 떄 아래와 같이 나온다.

sisung@C2r16s6 ~/workspace/42cursus/get_next_line
 % valgrind ./test_get_next_line 
==2951541== Memcheck, a memory error detector
==2951541== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==2951541== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2951541== Command: ./test_get_next_line
==2951541== 
==2951541== Conditional jump or move depends on uninitialised value(s)
==2951541==    at 0x401552: ft_strchr (get_next_line_utils.c:37)
==2951541==    by 0x40126B: get_next_line (get_next_line.c:30)
==2951541==    by 0x4011BB: main (main.c:10)
==2951541== 
hihi ojum bassa!
hello, world!

I'm sisung.

==2951541== 
==2951541== HEAP SUMMARY:
==2951541==     in use at exit: 0 bytes in 0 blocks
==2951541==   total heap usage: 22 allocs, 22 frees, 1,256 bytes allocated
==2951541== 
==2951541== All heap blocks were freed -- no leaks are possible
==2951541== 
==2951541== Use --track-origins=yes to see where uninitialised values come from
==2951541== For lists of detected and suppressed errors, rerun with: -s
==2951541== ERROR SUMMARY: 6 errors from 1 contexts (suppressed: 0 from 0)

여기서 ==2951541== ERROR SUMMARY: 6 errors from 1 contexts (suppressed: 0 from 0) 문구가 나오는데, 괜찮은건가?