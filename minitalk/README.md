# Minitalk

## 📌 프로젝트 목적
`Minitalk`은 **UNIX 시그널(`SIGUSR1`, `SIGUSR2`)**만을 사용하여 **클라이언트와 서버 간의 양방향 통신**을 구현하는 프로젝트.
이 과제를 통해 저수준 프로세스 간 통신(IPC, Inter-Process Communication)을 이해하고, 시그널 기반 데이터 전송의 한계와 특징을 학습하는 것.

---

## 📖 과제 개요
- **서버 (`server`)**
  - 실행 시 자신의 PID를 출력.
  - 클라이언트로부터 시그널을 통해 전송된 메시지를 수신하고 출력.
  - 여러 클라이언트의 메시지를 순차적으로 처리 가능해야됨.

- **클라이언트 (`client`)**
  - 실행 시 인자로 **서버 PID**와 **전송할 문자열**을 받기.
  - 문자열을 비트 단위로 변환하여 시그널(`SIGUSR1`, `SIGUSR2`)을 서버로 전송.
  - 보너스 파트에서는 서버로부터 **응답 시그널**을 받아 전송 완료 여부를 확인.

- **통신 방식**
  - `SIGUSR1`, `SIGUSR2` 두 가지 시그널만 사용.
  - 서버는 시그널을 통해 수신한 비트를 문자 단위로 재조립하고 문자열을 완성.

- **규칙**
  - 실행 파일 이름은 반드시 `server`, `client`.
  - 허용 함수:
    `write`, `signal`, `sigaction`, `kill`, `getpid`,
    `malloc`, `free`, `pause`, `sleep`, `usleep`, `exit`,
    `libft에 구현된 함수`.

---

## ⚙️ 구현 단계

### 1단계: 서버 구현
- [x] `getpid()`로 서버 PID 출력
- [x] `sigaction()`으로 시그널 핸들러 등록
- [x] 시그널을 비트 단위로 모아 문자를 재조립
- [x] 전체 문자열 출력
- [x] 무한 대기 루프 (`pause()` 또는 `while (1)`)

### 2단계: 클라이언트 구현
- [x] 인자 검사 (서버 PID, 문자열)
- [x] 문자열을 비트 단위로 변환
- [x] `kill()`을 이용해 비트별 시그널 전송
- [x] 서버로부터 수신확인(ACK)을 기다리는 핸드셰이크 구현

### 3단계: 보너스 구현
- [x] **서버 응답**: 서버는 메시지를 다 받은 후, `kill()`을 사용하여 클라이언트에게 확인 신호(`SIGUSR1`) 전송
- [x] **클라이언트 응답 처리**: 클라이언트는 서버로부터 응답을 수신하고 `"Message received!"` 같은 로그 출력
- [x] **UTF-8 지원**: 다바이트 이상 문자를 비트 단위로 올바르게 전송/재조립하도록 구현
- [x] 여러 클라이언트가 동시에 요청했을 때의 경쟁 조건 처리 (선택적 개선 사항)

---

## 🛠️ 디버깅 및 문제 해결 히스토리
[2025-09-05] - 긴 문자열 전송 시 데이터 손실
증상: 클라이언트가 서버로 긴 문자열을 보낼 때, 중간에 데이터가 누락되거나 깨져서 전달되는 현상이 발생.

원인 분석: 클라이언트의 send_message 함수 내에 있는 usleep(100) 함수가 문제의 원인. 이 함수는 비트 하나를 보낼 때마다 100 마이크로초(μs)씩 지연시키는 역할을 하지만, 이는 서버가 비트를 수신하고 처리하는 데 걸리는 시간을 보장하기에 충분하지 않았음. 특히 서버의 부하가 크거나 시스템 스케줄링에 따라 서버 프로세스가 지연되면, 클라이언트가 다음 비트를 보내기 전에 서버가 이전 비트를 처리하지 못하는 **경쟁 상태(race condition)**에 놓여 데이터가 유실됨.

해결 방안: 단순히 usleep을 사용하는 대신, 서버가 비트를 성공적으로 수신했음을 알리는 ACK(수신 확인) 신호를 주고받는 방식으로 변경. 클라이언트는 비트 하나를 보낼 때마다 서버로부터 SIGUSR1 시그널(ACK)을 받기 전까지는 다음 비트를 보내지 않도록 수정. 이로써 비트 전송과 수신 확인 과정을 동기화하여 안정적인 데이터 통신을 보장.

수정 전후 코드 확인:

수정 전: git show 54a92eefcb0e64c31c36b5e653e2a01977bc0e33

수정 후: git show 6b88b1f2d7b4178ccef2134a4ae11f2adb9c6c16

배운 점: usleep과 같은 고정된 지연 시간은 불안정한 통신 환경에서 문제를 일으킬 수 있음. 대신, **핸드셰이킹(handshaking)**처럼 송신자와 수신자가 서로의 상태를 확인하며 통신하는 방식이 훨씬 더 안정적이고 신뢰성 있는 데이터 전송을 보장한다는 것을 알게됨.

---

## 📂 디렉토리 구조
```bash
minitalk/
├── Makefile
├── include/
│   └── minitalk.h
├── src/
│   ├── client.c
│   ├── server.c
│   └── bonus/
│       ├── client_bonus.c
│       ├── server_bonus.c
└── README.md
```

---

## 🔨 빌드 및 실행 방법

### 빌드

```bash
make        # server와 client 실행 파일 생성
make bonus  # 보너스 버전(server_bonus, client_bonus) 생성
make clean  # 오브젝트 파일 삭제
make fclean # 실행 파일 및 오브젝트 파일 삭제
make re     # 전체 재빌드
```

### 실행

#### 필수 파트

1. 서버 실행

```bash
./server
# PID 출력
```

2. 클라이언트 실행

```bash
./client [서버 PID] "Hello World"
```

#### 보너스 파트

1. 서버 실행

```bash
./server_bonus
# PID 출력
```

2. 클라이언트 실행

```bash
./client_bonus [서버 PID] "안녕하세요 😀"
```

3. 실행 결과 예시

```bash
$ ./server_bonus
Server PID: 12345
Hello World
안녕하세요 😀

$ ./client_bonus 12345 "Hello World"
Message received!
```

---

## ✅ 제출 점검 리스트

* [x] 서버 실행 시 PID 출력
* [x] 클라이언트 → 서버 메시지 전송 성공
* [x] 여러 클라이언트 메시지 연속 수신 가능
* [x] 잘못된 인자/유효하지 않은 PID 입력 시 예외 처리
* [x] Norm 규칙 준수
* [x] 메모리 누수 없음
* [x] Makefile 규칙(`all`, `clean`, `fclean`, `re`, `bonus`) 정상 동작
* [x] 보너스: 서버 ↔ 클라이언트 응답 시그널
* [x] 보너스: UTF-8 문자 처리

---
